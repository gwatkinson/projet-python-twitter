<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>projet.visualisation API documentation</title>
<meta name="description" content="Visualisation des données" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>projet.visualisation</code></h1>
</header>
<section id="section-intro">
<p>Visualisation des données</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Visualisation des données&#34;&#34;&#34;

from bokeh.io import output_notebook, show, output_file, save
from bokeh.plotting import figure
from bokeh.models import GeoJSONDataSource, LinearColorMapper, ColorBar
from bokeh.palettes import brewer, d3
from bokeh.io import curdoc, output_notebook
from bokeh.models import Slider, HoverTool
from bokeh.layouts import widgetbox, row, column
import json
import numpy as np
import pandas as pd
import geopandas as gpd
import us
import matplotlib.pyplot as plt


def create_gdf(vars=[&#34;STUSPS10&#34;, &#34;NAME10&#34;, &#34;geometry&#34;]):
    &#34;&#34;&#34;
    Créée une geodataframe geopandas avec les États américains.

    Args:
        vars (list, optional): Liste des variables à garder.    
            Par défaut : `[&#34;STUSPS10&#34;, &#34;NAME10&#34;, &#34;geometry&#34;]`.

    Returns:
        geopandas.geodataframe: Une gdf de 50 lignes contenant la forme des États américains.
    &#34;&#34;&#34;
    states = us.STATES
    urls = [state.shapefile_urls(&#34;state&#34;) for state in states]
    gdf = pd.concat([gpd.read_file(url) for url in urls]).pipe(gpd.GeoDataFrame)
    return gdf[vars]


def add_max(
    df,
    df_state,
    label=&#34;kmlabel&#34;,
    var_state_df=&#34;state&#34;,
    var_state_gdf=&#34;NAME10&#34;,
    new_var=&#34;cluster_max&#34;,
):
    &#34;&#34;&#34;
    Ajoute le cluster majoritaire dans chaque État.

    Args:
        df (pandas.dataframe): La dataframe pandas avec les labels.

        df_state (geopandas.geodataframe): La gdf des États.

        label (str, optional): Le label à utiliser.    
            Par défaut : `&#34;kmlabel&#34;`.

        var_state_df (str, optional): Nom de la variable du nom des États dans la df.    
            Par défaut : `&#34;state&#34;`.

        var_state_gdf (str, optional): Nom de la variable du nom des États dans la gdf.    
            Par défaut : `&#34;NAME10&#34;`.

        new_var (str, optional): Nom de la nouvelle variable.    
            Le suffixe _{label} est ajouté.    
            Par défaut : `&#34;cluster_max&#34;`.

    Returns:
        geopandas.geodataframe: Modifie et renvoie la gdf des États avec le cluster majoritaire.
    &#34;&#34;&#34;

    def _add_max(row):
        state = row[var_state_gdf]
        if any(df[var_state_df] == state):
            df2 = df[df[var_state_df] == state].groupby(label).describe()
            m = df2[&#34;user-id&#34;][&#34;count&#34;]
            return m.idxmax()
        return np.nan

    df_state[f&#34;{new_var}_{label}&#34;] = df_state.apply(_add_max, axis=1)

    return df_state


def add_stats_sentiment(
    df,
    df_state,
    sent_var=&#34;full_text-sentiment-compound&#34;,
    var_state_df=&#34;state&#34;,
    var_state_gdf=&#34;NAME10&#34;,
):
    &#34;&#34;&#34;
    Ajoute des stats descriptive sur le compound du texte (count, mean, std).

    Args:
        df (pandas.dataframe): La dataframe pandas avec les labels.

        df_state (geopandas.geodataframe): La gdf des États.

        var_state_df (str, optional): Nom de la variable du nom des États dans la df.    
            Par défaut : `&#34;state&#34;`.

        var_state_gdf (str, optional): Nom de la variable du nom des États dans la gdf.    
            Par défaut : `&#34;NAME10&#34;`.

    Returns:
        geopandas.geodataframe: Modifie et renvoie la gdf des États avec les stats descriptive sur le compound du texte.
    &#34;&#34;&#34;
    df2 = df.groupby(var_state_df).describe()[sent_var][[&#34;count&#34;, &#34;mean&#34;, &#34;std&#34;]]
    df_state = df_state.merge(
        df2, how=&#34;left&#34;, left_on=[var_state_gdf], right_on=[var_state_df]
    )

    return df_state


def save_hist(
    df,
    df_state,
    label=&#34;kmlabel&#34;,
    var_state_df=&#34;state&#34;,
    var_state_gdf=&#34;NAME10&#34;,
    path=&#34;image/hist&#34;,
    new_var=&#34;hist&#34;,
):
    &#34;&#34;&#34;
    Créée les images des histogrammes par États puis ajoute une colonne avec les chemins vers les images.

    Args:
        df (pandas.dataframe): La dataframe pandas avec les labels.

        df_state (geopandas.geodataframe): La gdf des États.

        label (str, optional): Le label à utiliser.    
            Par défaut : `&#34;kmlabel&#34;`.

        var_state_df (str, optional): Nom de la variable du nom des États dans la df.    
            Par défaut : `&#34;state&#34;`.

        var_state_gdf (str, optional): Nom de la variable du nom des États dans la gdf.    
            Par défaut : `&#34;NAME10&#34;`.

        path (str, optional): Chemin où mettre les images.    
            Le suffixe _{label} est ajouté.    
            Par défaut : `&#34;image/hist&#34;`.

        new_var (str, optional): Nom de la nouvelle variable.    
            Le suffixe _{label} est ajouté.    
            Par défaut : `&#34;hist&#34;`.

    Returns:
        geopandas.geodataframe: Modifie et renvoie la gdf des États avec une colonne pour les histogrammes.
    &#34;&#34;&#34;

    def _add_image(row):
        state = row[var_state_gdf]
        if any(df[var_state_df] == state):
            df2 = df[df[var_state_df] == state].groupby(label).describe()
            m = df2[&#34;user-id&#34;][&#34;count&#34;]
            plt.figure(figsize=(10,10))
            fig = m.plot(
                kind=&#34;bar&#34;, title=f&#34;Histogramme de {state}&#34;, x=label, y=&#34;Count&#34;,
            ).get_figure()
            file = f&#34;{path}_{label}/hist_{label}_{state}.jpg&#34;
            fig.savefig(file)
            plt.close()
            return file
        return &#34;No data&#34;

    df_state[f&#34;{new_var}_{label}&#34;] = df_state.apply(_add_image, axis=1)

    return df_state


def plot_hist(
    df_state, label=&#34;kmlabel&#34;, path=&#34;&#34;, new_var=&#34;map&#34;, fill_var=&#34;cluster_max&#34;,
):
    &#34;&#34;&#34;
    Créée et affiche une carte interactive avec Bokeh.

    Args:
        df_state (geopandas.geodataframe): La gdf des États
            qui contient les images des histogrammes.

        label (str, optional): Le label à utiliser.    
            Par défaut : `&#34;kmlabel&#34;`.

        path (str, optional): Chemin où mettre les images.    
            Par défaut : `&#34;&#34;`.

        new_var (str, optional): Nom de la nouvelle variable.    
            Le suffixe _{label} est ajouté.    
            Par défaut : `&#34;map&#34;`.

        fill_var (str, optional): Nom de la variable des couleurs de la carte.    
            Le suffixe _{label} est ajouté.    
            Par défaut : `&#34;cluster_max&#34;`.
    &#34;&#34;&#34;
    # Fill nan
    df_state.fillna(&#34;No data&#34;, inplace=True)

    # Read data to json.
    df_state_json = json.loads(df_state.to_json())

    # Convert to String like object.
    json_data = json.dumps(df_state_json)

    # Input GeoJSON source that contains features for plotting.
    geosource = GeoJSONDataSource(geojson=json_data)

    tooltips_dict = {
        &#34;kmlabel&#34;: &#34;&#34;&#34;
        &lt;div&gt;
            &lt;div&gt;
                &lt;img
                    src=&#34;@hist_kmlabel&#34; alt=&#34;No image&#34; width=&#34;300&#34; height=&#34;300&#34;
                    style=&#34;float: left; margin: 0px 0px 0px 0px;&#34;
                    border=&#34;0&#34;
                &gt;&lt;/img&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &#34;&#34;&#34;,
        &#34;label&#34;: &#34;&#34;&#34;
        &lt;div&gt;
            &lt;div&gt;
                &lt;img
                    src=&#34;@hist_label&#34; alt=&#34;No image&#34; width=&#34;500&#34; height=&#34;500&#34;
                    style=&#34;float: left; margin: 0px 0px 0px 0px;&#34;
                    border=&#34;0&#34;
                &gt;&lt;/img&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &#34;&#34;&#34;,
    }

    # Add hover tool
    hover = HoverTool(tooltips=tooltips_dict[label])

    # Create figure object.
    p = figure(
        plot_height=600,
        plot_width=950,
        tools=[hover, &#34;pan,wheel_zoom,box_zoom,reset&#34;],
        toolbar_location=&#34;right&#34;,
        x_range=(-130, -64),
        y_range=(22, 50),
    )
    p.title.text = f&#34;Histogramme de &#39;{label}&#39;&#34;
    p.title.align = &#34;center&#34;
    p.title.text_font_size = &#34;25px&#34;
    p.xgrid.grid_line_color = None
    p.ygrid.grid_line_color = None

    n = df_state[f&#34;{fill_var}_{label}&#34;].nunique()
    if n &gt; 10:
        pal = brewer[&#34;YlGnBu&#34;]
    else:
        pal = brewer[&#34;Set3&#34;]
    palette = pal[n]
    color_mapper = LinearColorMapper(
        palette=palette, low=0, high=n, nan_color=&#34;#d9d9d9&#34;
    )
    # Add patch renderer to figure.
    p.patches(
        &#34;xs&#34;,
        &#34;ys&#34;,
        source=geosource,
        fill_color={&#34;field&#34;: f&#34;{fill_var}_{label}&#34;, &#34;transform&#34;: color_mapper},
        line_color=&#34;black&#34;,
        line_width=1,
        fill_alpha=1,
    )

    # Save map in html
    output_file(f&#34;{path}{new_var}_{label}.html&#34;, mode=&#34;inline&#34;)

    # Display figure inline in Jupyter Notebook.
    output_notebook()

    # Save figure.
    # save(p)
    # Display figure.
    show(p)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="projet.visualisation.add_max"><code class="name flex">
<span>def <span class="ident">add_max</span></span>(<span>df, df_state, label='kmlabel', var_state_df='state', var_state_gdf='NAME10', new_var='cluster_max')</span>
</code></dt>
<dd>
<div class="desc"><p>Ajoute le cluster majoritaire dans chaque État.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.dataframe</code></dt>
<dd>La dataframe pandas avec les labels.</dd>
<dt><strong><code>df_state</code></strong> :&ensp;<code>geopandas.geodataframe</code></dt>
<dd>La gdf des États.</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Le label à utiliser.
<br>
Par défaut : <code>"kmlabel"</code>.</dd>
<dt><strong><code>var_state_df</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Nom de la variable du nom des États dans la df.
<br>
Par défaut : <code>"state"</code>.</dd>
<dt><strong><code>var_state_gdf</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Nom de la variable du nom des États dans la gdf.
<br>
Par défaut : <code>"NAME10"</code>.</dd>
<dt><strong><code>new_var</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Nom de la nouvelle variable.
<br>
Le suffixe _{label} est ajouté.
<br>
Par défaut : <code>"cluster_max"</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.geodataframe</code></dt>
<dd>Modifie et renvoie la gdf des États avec le cluster majoritaire.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_max(
    df,
    df_state,
    label=&#34;kmlabel&#34;,
    var_state_df=&#34;state&#34;,
    var_state_gdf=&#34;NAME10&#34;,
    new_var=&#34;cluster_max&#34;,
):
    &#34;&#34;&#34;
    Ajoute le cluster majoritaire dans chaque État.

    Args:
        df (pandas.dataframe): La dataframe pandas avec les labels.

        df_state (geopandas.geodataframe): La gdf des États.

        label (str, optional): Le label à utiliser.    
            Par défaut : `&#34;kmlabel&#34;`.

        var_state_df (str, optional): Nom de la variable du nom des États dans la df.    
            Par défaut : `&#34;state&#34;`.

        var_state_gdf (str, optional): Nom de la variable du nom des États dans la gdf.    
            Par défaut : `&#34;NAME10&#34;`.

        new_var (str, optional): Nom de la nouvelle variable.    
            Le suffixe _{label} est ajouté.    
            Par défaut : `&#34;cluster_max&#34;`.

    Returns:
        geopandas.geodataframe: Modifie et renvoie la gdf des États avec le cluster majoritaire.
    &#34;&#34;&#34;

    def _add_max(row):
        state = row[var_state_gdf]
        if any(df[var_state_df] == state):
            df2 = df[df[var_state_df] == state].groupby(label).describe()
            m = df2[&#34;user-id&#34;][&#34;count&#34;]
            return m.idxmax()
        return np.nan

    df_state[f&#34;{new_var}_{label}&#34;] = df_state.apply(_add_max, axis=1)

    return df_state</code></pre>
</details>
</dd>
<dt id="projet.visualisation.add_stats_sentiment"><code class="name flex">
<span>def <span class="ident">add_stats_sentiment</span></span>(<span>df, df_state, sent_var='full_text-sentiment-compound', var_state_df='state', var_state_gdf='NAME10')</span>
</code></dt>
<dd>
<div class="desc"><p>Ajoute des stats descriptive sur le compound du texte (count, mean, std).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.dataframe</code></dt>
<dd>La dataframe pandas avec les labels.</dd>
<dt><strong><code>df_state</code></strong> :&ensp;<code>geopandas.geodataframe</code></dt>
<dd>La gdf des États.</dd>
<dt><strong><code>var_state_df</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Nom de la variable du nom des États dans la df.
<br>
Par défaut : <code>"state"</code>.</dd>
<dt><strong><code>var_state_gdf</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Nom de la variable du nom des États dans la gdf.
<br>
Par défaut : <code>"NAME10"</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.geodataframe</code></dt>
<dd>Modifie et renvoie la gdf des États avec les stats descriptive sur le compound du texte.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_stats_sentiment(
    df,
    df_state,
    sent_var=&#34;full_text-sentiment-compound&#34;,
    var_state_df=&#34;state&#34;,
    var_state_gdf=&#34;NAME10&#34;,
):
    &#34;&#34;&#34;
    Ajoute des stats descriptive sur le compound du texte (count, mean, std).

    Args:
        df (pandas.dataframe): La dataframe pandas avec les labels.

        df_state (geopandas.geodataframe): La gdf des États.

        var_state_df (str, optional): Nom de la variable du nom des États dans la df.    
            Par défaut : `&#34;state&#34;`.

        var_state_gdf (str, optional): Nom de la variable du nom des États dans la gdf.    
            Par défaut : `&#34;NAME10&#34;`.

    Returns:
        geopandas.geodataframe: Modifie et renvoie la gdf des États avec les stats descriptive sur le compound du texte.
    &#34;&#34;&#34;
    df2 = df.groupby(var_state_df).describe()[sent_var][[&#34;count&#34;, &#34;mean&#34;, &#34;std&#34;]]
    df_state = df_state.merge(
        df2, how=&#34;left&#34;, left_on=[var_state_gdf], right_on=[var_state_df]
    )

    return df_state</code></pre>
</details>
</dd>
<dt id="projet.visualisation.create_gdf"><code class="name flex">
<span>def <span class="ident">create_gdf</span></span>(<span>vars=['STUSPS10', 'NAME10', 'geometry'])</span>
</code></dt>
<dd>
<div class="desc"><p>Créée une geodataframe geopandas avec les États américains.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vars</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Liste des variables à garder.
<br>
Par défaut : <code>["STUSPS10", "NAME10", "geometry"]</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.geodataframe</code></dt>
<dd>Une gdf de 50 lignes contenant la forme des États américains.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_gdf(vars=[&#34;STUSPS10&#34;, &#34;NAME10&#34;, &#34;geometry&#34;]):
    &#34;&#34;&#34;
    Créée une geodataframe geopandas avec les États américains.

    Args:
        vars (list, optional): Liste des variables à garder.    
            Par défaut : `[&#34;STUSPS10&#34;, &#34;NAME10&#34;, &#34;geometry&#34;]`.

    Returns:
        geopandas.geodataframe: Une gdf de 50 lignes contenant la forme des États américains.
    &#34;&#34;&#34;
    states = us.STATES
    urls = [state.shapefile_urls(&#34;state&#34;) for state in states]
    gdf = pd.concat([gpd.read_file(url) for url in urls]).pipe(gpd.GeoDataFrame)
    return gdf[vars]</code></pre>
</details>
</dd>
<dt id="projet.visualisation.plot_hist"><code class="name flex">
<span>def <span class="ident">plot_hist</span></span>(<span>df_state, label='kmlabel', path='', new_var='map', fill_var='cluster_max')</span>
</code></dt>
<dd>
<div class="desc"><p>Créée et affiche une carte interactive avec Bokeh.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df_state</code></strong> :&ensp;<code>geopandas.geodataframe</code></dt>
<dd>La gdf des États
qui contient les images des histogrammes.</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Le label à utiliser.
<br>
Par défaut : <code>"kmlabel"</code>.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Chemin où mettre les images.
<br>
Par défaut : <code>""</code>.</dd>
<dt><strong><code>new_var</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Nom de la nouvelle variable.
<br>
Le suffixe _{label} est ajouté.
<br>
Par défaut : <code>"map"</code>.</dd>
<dt><strong><code>fill_var</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Nom de la variable des couleurs de la carte.
<br>
Le suffixe _{label} est ajouté.
<br>
Par défaut : <code>"cluster_max"</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_hist(
    df_state, label=&#34;kmlabel&#34;, path=&#34;&#34;, new_var=&#34;map&#34;, fill_var=&#34;cluster_max&#34;,
):
    &#34;&#34;&#34;
    Créée et affiche une carte interactive avec Bokeh.

    Args:
        df_state (geopandas.geodataframe): La gdf des États
            qui contient les images des histogrammes.

        label (str, optional): Le label à utiliser.    
            Par défaut : `&#34;kmlabel&#34;`.

        path (str, optional): Chemin où mettre les images.    
            Par défaut : `&#34;&#34;`.

        new_var (str, optional): Nom de la nouvelle variable.    
            Le suffixe _{label} est ajouté.    
            Par défaut : `&#34;map&#34;`.

        fill_var (str, optional): Nom de la variable des couleurs de la carte.    
            Le suffixe _{label} est ajouté.    
            Par défaut : `&#34;cluster_max&#34;`.
    &#34;&#34;&#34;
    # Fill nan
    df_state.fillna(&#34;No data&#34;, inplace=True)

    # Read data to json.
    df_state_json = json.loads(df_state.to_json())

    # Convert to String like object.
    json_data = json.dumps(df_state_json)

    # Input GeoJSON source that contains features for plotting.
    geosource = GeoJSONDataSource(geojson=json_data)

    tooltips_dict = {
        &#34;kmlabel&#34;: &#34;&#34;&#34;
        &lt;div&gt;
            &lt;div&gt;
                &lt;img
                    src=&#34;@hist_kmlabel&#34; alt=&#34;No image&#34; width=&#34;300&#34; height=&#34;300&#34;
                    style=&#34;float: left; margin: 0px 0px 0px 0px;&#34;
                    border=&#34;0&#34;
                &gt;&lt;/img&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &#34;&#34;&#34;,
        &#34;label&#34;: &#34;&#34;&#34;
        &lt;div&gt;
            &lt;div&gt;
                &lt;img
                    src=&#34;@hist_label&#34; alt=&#34;No image&#34; width=&#34;500&#34; height=&#34;500&#34;
                    style=&#34;float: left; margin: 0px 0px 0px 0px;&#34;
                    border=&#34;0&#34;
                &gt;&lt;/img&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &#34;&#34;&#34;,
    }

    # Add hover tool
    hover = HoverTool(tooltips=tooltips_dict[label])

    # Create figure object.
    p = figure(
        plot_height=600,
        plot_width=950,
        tools=[hover, &#34;pan,wheel_zoom,box_zoom,reset&#34;],
        toolbar_location=&#34;right&#34;,
        x_range=(-130, -64),
        y_range=(22, 50),
    )
    p.title.text = f&#34;Histogramme de &#39;{label}&#39;&#34;
    p.title.align = &#34;center&#34;
    p.title.text_font_size = &#34;25px&#34;
    p.xgrid.grid_line_color = None
    p.ygrid.grid_line_color = None

    n = df_state[f&#34;{fill_var}_{label}&#34;].nunique()
    if n &gt; 10:
        pal = brewer[&#34;YlGnBu&#34;]
    else:
        pal = brewer[&#34;Set3&#34;]
    palette = pal[n]
    color_mapper = LinearColorMapper(
        palette=palette, low=0, high=n, nan_color=&#34;#d9d9d9&#34;
    )
    # Add patch renderer to figure.
    p.patches(
        &#34;xs&#34;,
        &#34;ys&#34;,
        source=geosource,
        fill_color={&#34;field&#34;: f&#34;{fill_var}_{label}&#34;, &#34;transform&#34;: color_mapper},
        line_color=&#34;black&#34;,
        line_width=1,
        fill_alpha=1,
    )

    # Save map in html
    output_file(f&#34;{path}{new_var}_{label}.html&#34;, mode=&#34;inline&#34;)

    # Display figure inline in Jupyter Notebook.
    output_notebook()

    # Save figure.
    # save(p)
    # Display figure.
    show(p)</code></pre>
</details>
</dd>
<dt id="projet.visualisation.save_hist"><code class="name flex">
<span>def <span class="ident">save_hist</span></span>(<span>df, df_state, label='kmlabel', var_state_df='state', var_state_gdf='NAME10', path='image/hist', new_var='hist')</span>
</code></dt>
<dd>
<div class="desc"><p>Créée les images des histogrammes par États puis ajoute une colonne avec les chemins vers les images.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.dataframe</code></dt>
<dd>La dataframe pandas avec les labels.</dd>
<dt><strong><code>df_state</code></strong> :&ensp;<code>geopandas.geodataframe</code></dt>
<dd>La gdf des États.</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Le label à utiliser.
<br>
Par défaut : <code>"kmlabel"</code>.</dd>
<dt><strong><code>var_state_df</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Nom de la variable du nom des États dans la df.
<br>
Par défaut : <code>"state"</code>.</dd>
<dt><strong><code>var_state_gdf</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Nom de la variable du nom des États dans la gdf.
<br>
Par défaut : <code>"NAME10"</code>.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Chemin où mettre les images.
<br>
Le suffixe _{label} est ajouté.
<br>
Par défaut : <code>"image/hist"</code>.</dd>
<dt><strong><code>new_var</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Nom de la nouvelle variable.
<br>
Le suffixe _{label} est ajouté.
<br>
Par défaut : <code>"hist"</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.geodataframe</code></dt>
<dd>Modifie et renvoie la gdf des États avec une colonne pour les histogrammes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_hist(
    df,
    df_state,
    label=&#34;kmlabel&#34;,
    var_state_df=&#34;state&#34;,
    var_state_gdf=&#34;NAME10&#34;,
    path=&#34;image/hist&#34;,
    new_var=&#34;hist&#34;,
):
    &#34;&#34;&#34;
    Créée les images des histogrammes par États puis ajoute une colonne avec les chemins vers les images.

    Args:
        df (pandas.dataframe): La dataframe pandas avec les labels.

        df_state (geopandas.geodataframe): La gdf des États.

        label (str, optional): Le label à utiliser.    
            Par défaut : `&#34;kmlabel&#34;`.

        var_state_df (str, optional): Nom de la variable du nom des États dans la df.    
            Par défaut : `&#34;state&#34;`.

        var_state_gdf (str, optional): Nom de la variable du nom des États dans la gdf.    
            Par défaut : `&#34;NAME10&#34;`.

        path (str, optional): Chemin où mettre les images.    
            Le suffixe _{label} est ajouté.    
            Par défaut : `&#34;image/hist&#34;`.

        new_var (str, optional): Nom de la nouvelle variable.    
            Le suffixe _{label} est ajouté.    
            Par défaut : `&#34;hist&#34;`.

    Returns:
        geopandas.geodataframe: Modifie et renvoie la gdf des États avec une colonne pour les histogrammes.
    &#34;&#34;&#34;

    def _add_image(row):
        state = row[var_state_gdf]
        if any(df[var_state_df] == state):
            df2 = df[df[var_state_df] == state].groupby(label).describe()
            m = df2[&#34;user-id&#34;][&#34;count&#34;]
            plt.figure(figsize=(10,10))
            fig = m.plot(
                kind=&#34;bar&#34;, title=f&#34;Histogramme de {state}&#34;, x=label, y=&#34;Count&#34;,
            ).get_figure()
            file = f&#34;{path}_{label}/hist_{label}_{state}.jpg&#34;
            fig.savefig(file)
            plt.close()
            return file
        return &#34;No data&#34;

    df_state[f&#34;{new_var}_{label}&#34;] = df_state.apply(_add_image, axis=1)

    return df_state</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="projet" href="index.html">projet</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="projet.visualisation.add_max" href="#projet.visualisation.add_max">add_max</a></code></li>
<li><code><a title="projet.visualisation.add_stats_sentiment" href="#projet.visualisation.add_stats_sentiment">add_stats_sentiment</a></code></li>
<li><code><a title="projet.visualisation.create_gdf" href="#projet.visualisation.create_gdf">create_gdf</a></code></li>
<li><code><a title="projet.visualisation.plot_hist" href="#projet.visualisation.plot_hist">plot_hist</a></code></li>
<li><code><a title="projet.visualisation.save_hist" href="#projet.visualisation.save_hist">save_hist</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>