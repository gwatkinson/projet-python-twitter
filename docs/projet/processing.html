<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>projet.processing API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>projet.processing</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">## Process les tweets récupérés


## Import les modules
# Import les modules utilisés
import json
import pandas as pd
import numpy as np
import glob

# Erreurs du projet
import projet.projet_utils as utils

## Convertit et nettoie les tweets
def folder_to_path_list(folder_path):
    r&#34;&#34;&#34;
    Retourne la liste des fichiers `.json` dans le dossier donné.

    Args:
        folder_path (str): Chemin du dossier.
        Ne pas terminer avec un `/` ou `\`.

    Examples:
        folder_path(&#34;path/to/folder&#34;)
        folder_path(r&#34;path\to\folder&#34;)
    
    Returns:
        list: Liste des fichiers `.json` dans le dossier.
    &#34;&#34;&#34;
    path_list = glob.glob(folder_path + &#34;/*.json&#34;)

    return path_list


def tweet_json_to_df(path_list=None, folder=None):
    r&#34;&#34;&#34;
    Converti les fichiers json en dataframe pandas.

    Args:
        path_list (list, optional): 
            Une liste des chemin vers les fichiers `.json`.
        folder (str, optional): 
            Le chemin du dossier qui contient les fichiers `.json`.
            Ne pas terminer avec un `/` ou `\`.
    
    Returns:
        pandas.dataframe: Dataframe pandas qui contient les tweets.
    &#34;&#34;&#34;
    assert path_list is not None or folder is not None, &#34;Un argument est nécessaire&#34;
    assert path_list is None or (
        path_list
        and isinstance(path_list, list)
        and all(isinstance(path, str) for path in path_list)
    ), &#34;&#39;path_list&#39; doit être une liste de strings&#34;
    assert folder is None or isinstance(
        folder, str
    ), &#34;&#39;folder&#39; doit être une chaîne de caractères&#34;

    if path_list is None:
        path_list = folder_to_path_list(folder_path=folder)

    print(&#34;La conversion des fichiers &#39;json&#39; a commencé, cela peut prendre du temps&#34;)

    # Contient la liste des tweets en json
    tweets_list = []
    file_total = len(path_list)
    for i, path in enumerate(path_list):
        with open(path, &#34;r&#34;) as fh:
            tweets_json = fh.read().split(&#34;\n&#34;)
            for j, tweet in enumerate(tweets_json):
                tweet_total = len(tweets_json)
                if tweet:
                    tweet_obj = json.loads(tweet)
                    tweets_list.append(tweet_obj)
                utils.progressBar(j, tweet_total, file=i + 1, total_file=file_total)
        print(&#34;&#34;)

    # Créer une DataFrame à partir de `tweets_list`
    df_tweets = pd.DataFrame(tweets_list)

    # # Store the user screen name in &#39;user-screen_name&#39;
    # df_tweets[&#34;user-screen_name&#34;] = df_tweets[&#34;user&#34;][&#34;screen_name&#34;]

    # # Check if this is a 140+ character tweet
    # if &#34;extended_tweet&#34; in df_tweets:
    #     # Store the extended tweet text in &#39;extended_tweet-full_text&#39;
    #     df_tweets[&#34;extended_tweet-full_text&#34;] = df_tweets[&#34;extended_tweet&#34;][&#34;full_text&#34;]

    # Drop all the text duplicate (Est ce qu&#39;on a vraiment envie de supprimer les RT ?)
    # df_tweets = df_tweets.drop_duplicates(subset=[&#34;text&#34;])

    # Convert the created_at column to np.datetime object
    df_tweets[&#34;created_at&#34;] = pd.to_datetime(df_tweets[&#34;created_at&#34;])

    # Set the index of df_tweets to id
    df_tweets = df_tweets.set_index(&#34;id&#34;)

    return df_tweets


def select_time_range(df, start, end):
    &#34;&#34;&#34;
    Filtre les twwets.
    Garde les tweets créés entre les dates données. 

    Args:
        df (dataframe): La dataframe pandas qui contient les tweets.
        start (str): La date de départ.

            Au format: ``&#34;YYYY-MM-DD HH:MM:SS&#34;``.
        end (str): La date de fin
        
            Au format: ``&#34;YYYY-MM-DD HH:MM:SS&#34;``.

    Returns:
        pandas.dataframe: La dataframe filtrée.

    Examples:
        select_time_range(df, &#34;2020-11-03 08:15:00&#34;, &#34;2021-01-03 22:30:00&#34;)
    &#34;&#34;&#34;
    start_time = pd.to_datetime(start, &#34;%Y-%m-%d %H:%M:%S&#34;)
    end_time = pd.to_datetime(end, &#34;%Y-%m-%d %H:%M:%S&#34;)

    filtered_df = df[start_time &lt; df[&#34;created_at&#34;] &lt; end_time]

    return filtered_df


def filter_df(df):
    &#34;&#34;&#34;
    Fonction pour filtrer la df qui contient les tweets.

    Il s&#39;agit de selectionner les variables (donc garder que certaines colonnes) qui nous interresse 
    (text, full text, les counts, la localisation, on supprime retweeted_status et quoted_status).
    Il faut peut etre récuperer les counts via l&#39;API (car on récupère les nouveaux tweets et ils n&#34;ont pas encore de likes).
    Il faudra peut etre utiliser des expr reg pour nettoyer les rt.
    Mettre l&#39;option de choisir le timespan.

    Args:
        df ([type]): [description]
    &#34;&#34;&#34;
    pass


def nlp(df):
    &#34;&#34;&#34;
    Fonction pour ajouter la ou les colonnes de nlp (à l&#39;aide de nltk ou TextBlob ou les deux)

    Args:
        df ([type]): [description]
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="projet.processing.filter_df"><code class="name flex">
<span>def <span class="ident">filter_df</span></span>(<span>df)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction pour filtrer la df qui contient les tweets.</p>
<p>Il s'agit de selectionner les variables (donc garder que certaines colonnes) qui nous interresse
(text, full text, les counts, la localisation, on supprime retweeted_status et quoted_status).
Il faut peut etre récuperer les counts via l'API (car on récupère les nouveaux tweets et ils n"ont pas encore de likes).
Il faudra peut etre utiliser des expr reg pour nettoyer les rt.
Mettre l'option de choisir le timespan.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_df(df):
    &#34;&#34;&#34;
    Fonction pour filtrer la df qui contient les tweets.

    Il s&#39;agit de selectionner les variables (donc garder que certaines colonnes) qui nous interresse 
    (text, full text, les counts, la localisation, on supprime retweeted_status et quoted_status).
    Il faut peut etre récuperer les counts via l&#39;API (car on récupère les nouveaux tweets et ils n&#34;ont pas encore de likes).
    Il faudra peut etre utiliser des expr reg pour nettoyer les rt.
    Mettre l&#39;option de choisir le timespan.

    Args:
        df ([type]): [description]
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="projet.processing.folder_to_path_list"><code class="name flex">
<span>def <span class="ident">folder_to_path_list</span></span>(<span>folder_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Retourne la liste des fichiers <code>.json</code> dans le dossier donné.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>folder_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Chemin du dossier.</dd>
</dl>
<p>Ne pas terminer avec un <code>/</code> ou <code>\</code>.</p>
<h2 id="examples">Examples</h2>
<p>folder_path("path/to/folder")
folder_path(r"path\to\folder")</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>Liste des fichiers <code>.json</code> dans le dossier.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def folder_to_path_list(folder_path):
    r&#34;&#34;&#34;
    Retourne la liste des fichiers `.json` dans le dossier donné.

    Args:
        folder_path (str): Chemin du dossier.
        Ne pas terminer avec un `/` ou `\`.

    Examples:
        folder_path(&#34;path/to/folder&#34;)
        folder_path(r&#34;path\to\folder&#34;)
    
    Returns:
        list: Liste des fichiers `.json` dans le dossier.
    &#34;&#34;&#34;
    path_list = glob.glob(folder_path + &#34;/*.json&#34;)

    return path_list</code></pre>
</details>
</dd>
<dt id="projet.processing.nlp"><code class="name flex">
<span>def <span class="ident">nlp</span></span>(<span>df)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction pour ajouter la ou les colonnes de nlp (à l'aide de nltk ou TextBlob ou les deux)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nlp(df):
    &#34;&#34;&#34;
    Fonction pour ajouter la ou les colonnes de nlp (à l&#39;aide de nltk ou TextBlob ou les deux)

    Args:
        df ([type]): [description]
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="projet.processing.select_time_range"><code class="name flex">
<span>def <span class="ident">select_time_range</span></span>(<span>df, start, end)</span>
</code></dt>
<dd>
<div class="desc"><p>Filtre les twwets.
Garde les tweets créés entre les dates données. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>dataframe</code></dt>
<dd>La dataframe pandas qui contient les tweets.</dd>
<dt><strong><code>start</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>La date de départ.</p>
<p>Au format: <code>"YYYY-MM-DD HH:MM:SS"</code>.</p>
</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>La date de fin</p>
<p>Au format: <code>"YYYY-MM-DD HH:MM:SS"</code>.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.dataframe</code></dt>
<dd>La dataframe filtrée.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>select_time_range(df, "2020-11-03 08:15:00", "2021-01-03 22:30:00")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_time_range(df, start, end):
    &#34;&#34;&#34;
    Filtre les twwets.
    Garde les tweets créés entre les dates données. 

    Args:
        df (dataframe): La dataframe pandas qui contient les tweets.
        start (str): La date de départ.

            Au format: ``&#34;YYYY-MM-DD HH:MM:SS&#34;``.
        end (str): La date de fin
        
            Au format: ``&#34;YYYY-MM-DD HH:MM:SS&#34;``.

    Returns:
        pandas.dataframe: La dataframe filtrée.

    Examples:
        select_time_range(df, &#34;2020-11-03 08:15:00&#34;, &#34;2021-01-03 22:30:00&#34;)
    &#34;&#34;&#34;
    start_time = pd.to_datetime(start, &#34;%Y-%m-%d %H:%M:%S&#34;)
    end_time = pd.to_datetime(end, &#34;%Y-%m-%d %H:%M:%S&#34;)

    filtered_df = df[start_time &lt; df[&#34;created_at&#34;] &lt; end_time]

    return filtered_df</code></pre>
</details>
</dd>
<dt id="projet.processing.tweet_json_to_df"><code class="name flex">
<span>def <span class="ident">tweet_json_to_df</span></span>(<span>path_list=None, folder=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Converti les fichiers json en dataframe pandas.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path_list</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Une liste des chemin vers les fichiers <code>.json</code>.</dd>
<dt><strong><code>folder</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Le chemin du dossier qui contient les fichiers <code>.json</code>.
Ne pas terminer avec un <code>/</code> ou <code>\</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.dataframe</code></dt>
<dd>Dataframe pandas qui contient les tweets.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tweet_json_to_df(path_list=None, folder=None):
    r&#34;&#34;&#34;
    Converti les fichiers json en dataframe pandas.

    Args:
        path_list (list, optional): 
            Une liste des chemin vers les fichiers `.json`.
        folder (str, optional): 
            Le chemin du dossier qui contient les fichiers `.json`.
            Ne pas terminer avec un `/` ou `\`.
    
    Returns:
        pandas.dataframe: Dataframe pandas qui contient les tweets.
    &#34;&#34;&#34;
    assert path_list is not None or folder is not None, &#34;Un argument est nécessaire&#34;
    assert path_list is None or (
        path_list
        and isinstance(path_list, list)
        and all(isinstance(path, str) for path in path_list)
    ), &#34;&#39;path_list&#39; doit être une liste de strings&#34;
    assert folder is None or isinstance(
        folder, str
    ), &#34;&#39;folder&#39; doit être une chaîne de caractères&#34;

    if path_list is None:
        path_list = folder_to_path_list(folder_path=folder)

    print(&#34;La conversion des fichiers &#39;json&#39; a commencé, cela peut prendre du temps&#34;)

    # Contient la liste des tweets en json
    tweets_list = []
    file_total = len(path_list)
    for i, path in enumerate(path_list):
        with open(path, &#34;r&#34;) as fh:
            tweets_json = fh.read().split(&#34;\n&#34;)
            for j, tweet in enumerate(tweets_json):
                tweet_total = len(tweets_json)
                if tweet:
                    tweet_obj = json.loads(tweet)
                    tweets_list.append(tweet_obj)
                utils.progressBar(j, tweet_total, file=i + 1, total_file=file_total)
        print(&#34;&#34;)

    # Créer une DataFrame à partir de `tweets_list`
    df_tweets = pd.DataFrame(tweets_list)

    # # Store the user screen name in &#39;user-screen_name&#39;
    # df_tweets[&#34;user-screen_name&#34;] = df_tweets[&#34;user&#34;][&#34;screen_name&#34;]

    # # Check if this is a 140+ character tweet
    # if &#34;extended_tweet&#34; in df_tweets:
    #     # Store the extended tweet text in &#39;extended_tweet-full_text&#39;
    #     df_tweets[&#34;extended_tweet-full_text&#34;] = df_tweets[&#34;extended_tweet&#34;][&#34;full_text&#34;]

    # Drop all the text duplicate (Est ce qu&#39;on a vraiment envie de supprimer les RT ?)
    # df_tweets = df_tweets.drop_duplicates(subset=[&#34;text&#34;])

    # Convert the created_at column to np.datetime object
    df_tweets[&#34;created_at&#34;] = pd.to_datetime(df_tweets[&#34;created_at&#34;])

    # Set the index of df_tweets to id
    df_tweets = df_tweets.set_index(&#34;id&#34;)

    return df_tweets</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="projet" href="index.html">projet</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="projet.processing.filter_df" href="#projet.processing.filter_df">filter_df</a></code></li>
<li><code><a title="projet.processing.folder_to_path_list" href="#projet.processing.folder_to_path_list">folder_to_path_list</a></code></li>
<li><code><a title="projet.processing.nlp" href="#projet.processing.nlp">nlp</a></code></li>
<li><code><a title="projet.processing.select_time_range" href="#projet.processing.select_time_range">select_time_range</a></code></li>
<li><code><a title="projet.processing.tweet_json_to_df" href="#projet.processing.tweet_json_to_df">tweet_json_to_df</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>