<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>projet.processing API documentation</title>
<meta name="description" content="Process les tweets récupérés" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>projet.processing</code></h1>
</header>
<section id="section-intro">
<p>Process les tweets récupérés</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Process les tweets récupérés&#34;&#34;&#34;

# Import les modules utilisés
import json
import pandas as pd
import numpy as np
import glob
import nltk

nltk.download(&#34;vader_lexicon&#34;)
from nltk.sentiment.vader import SentimentIntensityAnalyzer

# Import les listes de variables
import projet.listes_variables

# Import les utils du projet
import projet.projet_utils as utils


# Convertit les fichiers json en dataframe
def folder_to_path_list(folder_path):
    r&#34;&#34;&#34;
    Retourne la liste des fichiers `.json` dans le dossier donné.

    Args:
        folder_path (str): Chemin du dossier.
        À terminer avec un `/` ou `\`.

    Examples:
        folder_path(&#34;path/to/folder&#34;)
        folder_path(r&#34;path\to\folder&#34;)

    Returns:
        list: Liste des fichiers `.json` dans le dossier.
    &#34;&#34;&#34;
    path_list = glob.glob(folder_path + &#34;*.json&#34;)

    return path_list


def tweet_json_to_df(path_list=None, folder=None, verbose=False):
    r&#34;&#34;&#34;
    Convertit les fichiers json en dataframe pandas.

    Args:
        path_list (list, optional): 
            Une liste des chemin vers les fichiers `.json`.
        folder (str, optional): 
            Le chemin du dossier qui contient les fichiers `.json`.

            À terminer avec un `/` ou `\`.
        verbose (bool, optional): 
            `True` pour afficher une barre de progrès et des messages.

            Par défaut : `False`.

    Returns:
        pandas.dataframe: Dataframe pandas qui contient les tweets.
    &#34;&#34;&#34;
    assert path_list is not None or folder is not None, &#34;Un argument est nécessaire&#34;
    assert path_list is None or (
        path_list
        and isinstance(path_list, list)
        and all(isinstance(path, str) for path in path_list)
    ), &#34;&#39;path_list&#39; doit être une liste de strings&#34;
    assert folder is None or isinstance(
        folder, str
    ), &#34;&#39;folder&#39; doit être une chaîne de caractères&#34;

    if path_list is None:
        path_list = folder_to_path_list(folder_path=folder)

    if verbose:
        print(
            &#34;La conversion des fichiers &#39;json&#39; a commencé, cela peut prendre du temps&#34;
        )

    # Contient la liste des tweets en json
    tweets_list = []
    file_total = len(path_list)
    for i, path in enumerate(path_list):
        with open(path, &#34;r&#34;) as fh:
            tweets_json = fh.read().split(&#34;\n&#34;)
            for j, tweet in enumerate(tweets_json):
                tweet_total = len(tweets_json)
                if tweet:
                    tweet_obj = json.loads(tweet)
                    tweets_list.append(tweet_obj)
                utils.progressBar(
                    j, tweet_total, file=i + 1, total_file=file_total, verbose=verbose
                )
        if verbose:
            print(&#34;&#34;)

    # Créer une DataFrame à partir de `tweets_list`
    df_tweets = pd.DataFrame(tweets_list)

    return df_tweets


# Nettoie la dataframe
def clean_df(
    df,
    index=&#34;id&#34;,
    date=&#34;created_at&#34;,
    verbose=False,
    extra=None,
    vars=projet.listes_variables.liste_1,
):
    &#34;&#34;&#34;
    Fonction pour nettoyer la df qui contient les tweets.

    Il s&#39;agit de selectionner les variables (donc garder que certaines colonnes) qui nous interresse 
    (text, , les counts, la localisation, on supprime retweeted_status et quoted_status).
    Il faut peut etre récuperer les counts via l&#39;API (car on récupère les nouveaux tweets et ils n&#34;ont pas encore de likes).
    Il faudra peut etre utiliser des expr reg pour nettoyer les rt.

    Args:
        df (pandas.dataframe): Dataframe non nettoyée qui contient les tweets.
        index (str, optional): 
            Nom de la colonne de `df` à mettre en index.

            Mettre `None` pour ne pas avoir d&#39;index.

            Par défaut : `id`.
        date (str, optional): 
            Nom de la variable de `df` qui contient la date.

            Mettre `None` pour ne pas avoir de date.

            Par défaut : `created_at`.
        vars (list, optional): 

        extra (list, optional): 
            Même format que vars.

            À utiliser pour ajouter des variables à la valeur par défaut de `vars`.
        verbose (bool, optional): 
            `True` pour afficher une barre de progrès et des messages.

            Par défaut : `False`.

    Returns:
        pandas.dataframe: La dataframe nettoyée.
    &#34;&#34;&#34;
    # Ajoute les extra à la liste des variables
    columns = vars.copy()
    if extra:
        columns.append(extra)

    # Vérifie que toute les variables données existent dans df
    wrong_var = [
        list(var)[0]
        for var in [[index], [date]] + columns
        if var and list(var)[0] not in list(df)
    ]
    if wrong_var:
        raise utils.WrongColumnName(var=wrong_var)

    total = len(columns) + 3

    if verbose:
        print(&#34;Le nettoyage a commencé&#34;)

    # Initialise la df
    clean_df = pd.DataFrame()

    # Ajoute la date au format datetime
    if date:
        clean_df[date] = pd.to_datetime(df[date])
    utils.progressBar(current=1, total=total, verbose=verbose)

    # Ajoute les variables
    for i, var in enumerate(columns):
        var_name = &#34;-&#34;.join(var)
        new_col = df[list(var)[0]]
        for i in range(1, len(var)):
            new_col = [
                new_col[j].get(var[i], np.nan)
                if isinstance(new_col[j], dict)
                else np.nan
                for j in range(len(new_col))
            ]
        clean_df[var_name] = new_col
        utils.progressBar(current=i + 2, total=total, verbose=verbose)

    # Convertit la date de création des accounts
    if &#34;user-created_at&#34; in clean_df:
        clean_df[&#34;user-created_at&#34;] = pd.to_datetime(clean_df[&#34;user-created_at&#34;])
    utils.progressBar(current=total - 1, total=total, verbose=verbose)

    # Ajoute les index
    if index:
        clean_df = clean_df.set_index(df[index])
    utils.progressBar(current=total, total=total, verbose=verbose)

    if verbose:
        print(&#34;&#34;)

    return clean_df


# Fonctions pour ajouter des colonnes
def create_full_text(df):
    &#34;&#34;&#34;
    Fonction pour ajouter le texte entier et gérer les RT.
    
    Args:
        df (pandas.dataframe): 
            Une dataframe pandas du type `clean_df`.

    Returns:
        pandas.dataframe: Une df avec une nouvelle colonne `full_text`.
    &#34;&#34;&#34;
    new_col = []
    for i in range(len(df)):
        if df[&#34;extended_tweet-full_text&#34;].iloc[i] is not np.nan:
            t = df[&#34;extended_tweet-full_text&#34;].iloc[i]
        elif df[&#34;retweeted_status-extended_tweet-full_text&#34;].iloc[i] is not np.nan:
            t = df[&#34;retweeted_status-extended_tweet-full_text&#34;].iloc[i]
        elif df[&#34;retweeted_status-text&#34;].iloc[i] is not np.nan:
            t = df[&#34;retweeted_status-text&#34;].iloc[i]
        elif df[&#34;text&#34;].iloc[i] is not np.nan:
            t = df[&#34;text&#34;].iloc[i]
        new_col.append(t)

    df[&#34;full_text&#34;] = new_col

    return df


def add_sentiment(df):
    &#34;&#34;&#34;
    Fonction pour ajouter la ou les colonnes de sentiment analysis (à l&#39;aide de nltk ou TextBlob ou les deux).

    Args:
        df (pandas.dataframe): Une dataframe pandas du type `create_full_text`.
    &#34;&#34;&#34;
    sid = SentimentIntensityAnalyzer()

    # Generate sentiment scores
    df[&#34;full_text-sentiment&#34;] = df[&#34;full_text&#34;].apply(sid.polarity_scores)
    df[&#34;full_text-sentiment-compound&#34;] = df[&#34;full_text-sentiment&#34;].apply(
        lambda s: s.get(&#34;compound&#34;)
    )
    df[&#34;user-description-sentiment&#34;] = (
        df[&#34;user-description&#34;].fillna(value=&#34;&#34;).apply(sid.polarity_scores)
    )
    df[&#34;user-description-sentiment-compound&#34;] = df[&#34;user-description-sentiment&#34;].apply(
        lambda s: s.get(&#34;compound&#34;)
    )

    return df


def add_politics(df):
    &#34;&#34;&#34;
    Fonction pour ajouter une colonne pour la présence ou non de Trump et une pour Biden.

    Args:
        df (pandas.dataframe): Une dataframe pandas du type `create_full_text`.
    &#34;&#34;&#34;
    Trump_word = &#34;(Trump|Donald|realDonaldTrump|republican)&#34;
    Biden_word = &#34;(Biden|Joe|JoeBiden|democrat)&#34;
    df[&#34;contains_trump&#34;] = df[&#34;full_text&#34;].str.contains(Trump_word, case=False)
    df[&#34;contains_biden&#34;] = df[&#34;full_text&#34;].str.contains(Biden_word, case=False)
    df[&#34;user-description-contains_trump&#34;] = df[&#34;user-description&#34;].str.contains(
        Trump_word, case=False
    )
    df[&#34;user-description-contains_biden&#34;] = df[&#34;user-description&#34;].str.contains(
        Biden_word, case=False
    )

    return df


def sentiment_class(
    df,
    vars=[&#34;full_text&#34;, &#34;user-description&#34;],
    choices=[&#34;tneg&#34;, &#34;neg&#34;, &#34;neutre&#34;, &#34;pos&#34;, &#34;tpos&#34;],
):
    &#34;&#34;&#34;
    Fonction pour ajouter une colonne pour les valeurs discrétisées de sentiment_analysis.

    Args:
        df (pandas.dataframe): Une dataframe pandas du type `create_full_text`.
    &#34;&#34;&#34;
    conditions = lambda s: [
        (df[s + &#34;-sentiment-compound&#34;].lt(-0.7)),
        (
            df[s + &#34;-sentiment-compound&#34;].ge(-0.7)
            &amp; df[s + &#34;-sentiment-compound&#34;].lt(-0.2)
        ),
        (
            df[s + &#34;-sentiment-compound&#34;].ge(-0.2)
            &amp; df[s + &#34;-sentiment-compound&#34;].lt(0.2)
        ),
        (df[s + &#34;-sentiment-compound&#34;].ge(0.2) &amp; df[s + &#34;-sentiment-compound&#34;].lt(0.7)),
        (df[s + &#34;-sentiment-compound&#34;].ge(0.7)),
    ]

    for var in vars:
        df[var + &#34;-sentiment-class&#34;] = np.select(conditions(var), choices)

    return df


def add_category(df):
    &#34;&#34;&#34;
    Fonction pour ajouter une colonne pour les valeurs discrétisées de sentiment_analysis.

    Args:
        df (pandas.dataframe): Une dataframe pandas du type `create_full_text`.
    &#34;&#34;&#34;
    conditions = [()]
    pass


# Fonctions pour filtrer la dataframe
def select_time_range(df, start, end, date_var=&#34;created_at&#34;):
    &#34;&#34;&#34;
    Filtre les tweets.
    Garde les tweets créés entre les dates données. 

    Args:
        df (dataframe): La dataframe pandas qui contient les tweets.
        start (str): La date de départ.

            Au format: `` &#34;%Y-%m-%d %H:%M:%S%z&#34;``.
        end (str): La date de fin

            Au format: `` &#34;%Y-%m-%d %H:%M:%S%z&#34;``.
        date_var (str): Le nom de la colonne qui contient la date

    Returns:
        pandas.dataframe: La dataframe filtrée par le temps.

    Examples:
        select_time_range(df, &#34;2020-11-03 08:15:00+01:00&#34;, &#34;2021-01-03 22:30:00+01:00&#34;)
    &#34;&#34;&#34;
    start_time = pd.to_datetime(start)
    end_time = pd.to_datetime(end)

    filtered_df = df[(start_time &lt; df[date_var]) &amp; (df[date_var] &lt; end_time)]

    return filtered_df</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="projet.processing.add_category"><code class="name flex">
<span>def <span class="ident">add_category</span></span>(<span>df)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction pour ajouter une colonne pour les valeurs discrétisées de sentiment_analysis.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.dataframe</code></dt>
<dd>Une dataframe pandas du type <code><a title="projet.processing.create_full_text" href="#projet.processing.create_full_text">create_full_text()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_category(df):
    &#34;&#34;&#34;
    Fonction pour ajouter une colonne pour les valeurs discrétisées de sentiment_analysis.

    Args:
        df (pandas.dataframe): Une dataframe pandas du type `create_full_text`.
    &#34;&#34;&#34;
    conditions = [()]
    pass</code></pre>
</details>
</dd>
<dt id="projet.processing.add_politics"><code class="name flex">
<span>def <span class="ident">add_politics</span></span>(<span>df)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction pour ajouter une colonne pour la présence ou non de Trump et une pour Biden.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.dataframe</code></dt>
<dd>Une dataframe pandas du type <code><a title="projet.processing.create_full_text" href="#projet.processing.create_full_text">create_full_text()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_politics(df):
    &#34;&#34;&#34;
    Fonction pour ajouter une colonne pour la présence ou non de Trump et une pour Biden.

    Args:
        df (pandas.dataframe): Une dataframe pandas du type `create_full_text`.
    &#34;&#34;&#34;
    Trump_word = &#34;(Trump|Donald|realDonaldTrump|republican)&#34;
    Biden_word = &#34;(Biden|Joe|JoeBiden|democrat)&#34;
    df[&#34;contains_trump&#34;] = df[&#34;full_text&#34;].str.contains(Trump_word, case=False)
    df[&#34;contains_biden&#34;] = df[&#34;full_text&#34;].str.contains(Biden_word, case=False)
    df[&#34;user-description-contains_trump&#34;] = df[&#34;user-description&#34;].str.contains(
        Trump_word, case=False
    )
    df[&#34;user-description-contains_biden&#34;] = df[&#34;user-description&#34;].str.contains(
        Biden_word, case=False
    )

    return df</code></pre>
</details>
</dd>
<dt id="projet.processing.add_sentiment"><code class="name flex">
<span>def <span class="ident">add_sentiment</span></span>(<span>df)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction pour ajouter la ou les colonnes de sentiment analysis (à l'aide de nltk ou TextBlob ou les deux).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.dataframe</code></dt>
<dd>Une dataframe pandas du type <code><a title="projet.processing.create_full_text" href="#projet.processing.create_full_text">create_full_text()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_sentiment(df):
    &#34;&#34;&#34;
    Fonction pour ajouter la ou les colonnes de sentiment analysis (à l&#39;aide de nltk ou TextBlob ou les deux).

    Args:
        df (pandas.dataframe): Une dataframe pandas du type `create_full_text`.
    &#34;&#34;&#34;
    sid = SentimentIntensityAnalyzer()

    # Generate sentiment scores
    df[&#34;full_text-sentiment&#34;] = df[&#34;full_text&#34;].apply(sid.polarity_scores)
    df[&#34;full_text-sentiment-compound&#34;] = df[&#34;full_text-sentiment&#34;].apply(
        lambda s: s.get(&#34;compound&#34;)
    )
    df[&#34;user-description-sentiment&#34;] = (
        df[&#34;user-description&#34;].fillna(value=&#34;&#34;).apply(sid.polarity_scores)
    )
    df[&#34;user-description-sentiment-compound&#34;] = df[&#34;user-description-sentiment&#34;].apply(
        lambda s: s.get(&#34;compound&#34;)
    )

    return df</code></pre>
</details>
</dd>
<dt id="projet.processing.clean_df"><code class="name flex">
<span>def <span class="ident">clean_df</span></span>(<span>df, index='id', date='created_at', verbose=False, extra=None, vars=[['text'], ['extended_tweet', 'full_text'], ['lang'], ['retweeted_status', 'user', 'screen_name'], ['retweeted_status', 'text'], ['retweeted_status', 'extended_tweet', 'full_text'], ['user', 'id'], ['user', 'name'], ['user', 'screen_name'], ['user', 'location'], ['user', 'description'], ['user', 'followers_count'], ['user', 'friends_count'], ['user', 'listed_count'], ['user', 'favourites_count'], ['user', 'statuses_count'], ['place', 'name'], ['place', 'full_name'], ['place', 'place_type'], ['place', 'country_code'], ['place', 'country'], ['place', 'bounding_box', 'type'], ['place', 'bounding_box', 'coordinates']])</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction pour nettoyer la df qui contient les tweets.</p>
<p>Il s'agit de selectionner les variables (donc garder que certaines colonnes) qui nous interresse
(text, , les counts, la localisation, on supprime retweeted_status et quoted_status).
Il faut peut etre récuperer les counts via l'API (car on récupère les nouveaux tweets et ils n"ont pas encore de likes).
Il faudra peut etre utiliser des expr reg pour nettoyer les rt.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.dataframe</code></dt>
<dd>Dataframe non nettoyée qui contient les tweets.</dd>
<dt><strong><code>index</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>
<p>Nom de la colonne de <code>df</code> à mettre en index.</p>
<p>Mettre <code>None</code> pour ne pas avoir d'index.</p>
<p>Par défaut : <code>id</code>.</p>
</dd>
<dt><strong><code>date</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>
<p>Nom de la variable de <code>df</code> qui contient la date.</p>
<p>Mettre <code>None</code> pour ne pas avoir de date.</p>
<p>Par défaut : <code>created_at</code>.</p>
</dd>
<dt><strong><code>vars</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd></dd>
<dt><strong><code>extra</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>
<p>Même format que vars.</p>
<p>À utiliser pour ajouter des variables à la valeur par défaut de <code>vars</code>.</p>
</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>
<p><code>True</code> pour afficher une barre de progrès et des messages.</p>
<p>Par défaut : <code>False</code>.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.dataframe</code></dt>
<dd>La dataframe nettoyée.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_df(
    df,
    index=&#34;id&#34;,
    date=&#34;created_at&#34;,
    verbose=False,
    extra=None,
    vars=projet.listes_variables.liste_1,
):
    &#34;&#34;&#34;
    Fonction pour nettoyer la df qui contient les tweets.

    Il s&#39;agit de selectionner les variables (donc garder que certaines colonnes) qui nous interresse 
    (text, , les counts, la localisation, on supprime retweeted_status et quoted_status).
    Il faut peut etre récuperer les counts via l&#39;API (car on récupère les nouveaux tweets et ils n&#34;ont pas encore de likes).
    Il faudra peut etre utiliser des expr reg pour nettoyer les rt.

    Args:
        df (pandas.dataframe): Dataframe non nettoyée qui contient les tweets.
        index (str, optional): 
            Nom de la colonne de `df` à mettre en index.

            Mettre `None` pour ne pas avoir d&#39;index.

            Par défaut : `id`.
        date (str, optional): 
            Nom de la variable de `df` qui contient la date.

            Mettre `None` pour ne pas avoir de date.

            Par défaut : `created_at`.
        vars (list, optional): 

        extra (list, optional): 
            Même format que vars.

            À utiliser pour ajouter des variables à la valeur par défaut de `vars`.
        verbose (bool, optional): 
            `True` pour afficher une barre de progrès et des messages.

            Par défaut : `False`.

    Returns:
        pandas.dataframe: La dataframe nettoyée.
    &#34;&#34;&#34;
    # Ajoute les extra à la liste des variables
    columns = vars.copy()
    if extra:
        columns.append(extra)

    # Vérifie que toute les variables données existent dans df
    wrong_var = [
        list(var)[0]
        for var in [[index], [date]] + columns
        if var and list(var)[0] not in list(df)
    ]
    if wrong_var:
        raise utils.WrongColumnName(var=wrong_var)

    total = len(columns) + 3

    if verbose:
        print(&#34;Le nettoyage a commencé&#34;)

    # Initialise la df
    clean_df = pd.DataFrame()

    # Ajoute la date au format datetime
    if date:
        clean_df[date] = pd.to_datetime(df[date])
    utils.progressBar(current=1, total=total, verbose=verbose)

    # Ajoute les variables
    for i, var in enumerate(columns):
        var_name = &#34;-&#34;.join(var)
        new_col = df[list(var)[0]]
        for i in range(1, len(var)):
            new_col = [
                new_col[j].get(var[i], np.nan)
                if isinstance(new_col[j], dict)
                else np.nan
                for j in range(len(new_col))
            ]
        clean_df[var_name] = new_col
        utils.progressBar(current=i + 2, total=total, verbose=verbose)

    # Convertit la date de création des accounts
    if &#34;user-created_at&#34; in clean_df:
        clean_df[&#34;user-created_at&#34;] = pd.to_datetime(clean_df[&#34;user-created_at&#34;])
    utils.progressBar(current=total - 1, total=total, verbose=verbose)

    # Ajoute les index
    if index:
        clean_df = clean_df.set_index(df[index])
    utils.progressBar(current=total, total=total, verbose=verbose)

    if verbose:
        print(&#34;&#34;)

    return clean_df</code></pre>
</details>
</dd>
<dt id="projet.processing.create_full_text"><code class="name flex">
<span>def <span class="ident">create_full_text</span></span>(<span>df)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction pour ajouter le texte entier et gérer les RT.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.dataframe</code></dt>
<dd>Une dataframe pandas du type <code><a title="projet.processing.clean_df" href="#projet.processing.clean_df">clean_df()</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.dataframe</code></dt>
<dd>Une df avec une nouvelle colonne <code>full_text</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_full_text(df):
    &#34;&#34;&#34;
    Fonction pour ajouter le texte entier et gérer les RT.
    
    Args:
        df (pandas.dataframe): 
            Une dataframe pandas du type `clean_df`.

    Returns:
        pandas.dataframe: Une df avec une nouvelle colonne `full_text`.
    &#34;&#34;&#34;
    new_col = []
    for i in range(len(df)):
        if df[&#34;extended_tweet-full_text&#34;].iloc[i] is not np.nan:
            t = df[&#34;extended_tweet-full_text&#34;].iloc[i]
        elif df[&#34;retweeted_status-extended_tweet-full_text&#34;].iloc[i] is not np.nan:
            t = df[&#34;retweeted_status-extended_tweet-full_text&#34;].iloc[i]
        elif df[&#34;retweeted_status-text&#34;].iloc[i] is not np.nan:
            t = df[&#34;retweeted_status-text&#34;].iloc[i]
        elif df[&#34;text&#34;].iloc[i] is not np.nan:
            t = df[&#34;text&#34;].iloc[i]
        new_col.append(t)

    df[&#34;full_text&#34;] = new_col

    return df</code></pre>
</details>
</dd>
<dt id="projet.processing.folder_to_path_list"><code class="name flex">
<span>def <span class="ident">folder_to_path_list</span></span>(<span>folder_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Retourne la liste des fichiers <code>.json</code> dans le dossier donné.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>folder_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Chemin du dossier.</dd>
</dl>
<p>À terminer avec un <code>/</code> ou <code>\</code>.</p>
<h2 id="examples">Examples</h2>
<p>folder_path("path/to/folder")
folder_path(r"path\to\folder")</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>Liste des fichiers <code>.json</code> dans le dossier.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def folder_to_path_list(folder_path):
    r&#34;&#34;&#34;
    Retourne la liste des fichiers `.json` dans le dossier donné.

    Args:
        folder_path (str): Chemin du dossier.
        À terminer avec un `/` ou `\`.

    Examples:
        folder_path(&#34;path/to/folder&#34;)
        folder_path(r&#34;path\to\folder&#34;)

    Returns:
        list: Liste des fichiers `.json` dans le dossier.
    &#34;&#34;&#34;
    path_list = glob.glob(folder_path + &#34;*.json&#34;)

    return path_list</code></pre>
</details>
</dd>
<dt id="projet.processing.select_time_range"><code class="name flex">
<span>def <span class="ident">select_time_range</span></span>(<span>df, start, end, date_var='created_at')</span>
</code></dt>
<dd>
<div class="desc"><p>Filtre les tweets.
Garde les tweets créés entre les dates données. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>dataframe</code></dt>
<dd>La dataframe pandas qui contient les tweets.</dd>
<dt><strong><code>start</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>La date de départ.</p>
<p>Au format: <code>"%Y-%m-%d %H:%M:%S%z"</code>.</p>
</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>La date de fin</p>
<p>Au format: <code>"%Y-%m-%d %H:%M:%S%z"</code>.</p>
</dd>
<dt><strong><code>date_var</code></strong> :&ensp;<code>str</code></dt>
<dd>Le nom de la colonne qui contient la date</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.dataframe</code></dt>
<dd>La dataframe filtrée par le temps.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>select_time_range(df, "2020-11-03 08:15:00+01:00", "2021-01-03 22:30:00+01:00")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_time_range(df, start, end, date_var=&#34;created_at&#34;):
    &#34;&#34;&#34;
    Filtre les tweets.
    Garde les tweets créés entre les dates données. 

    Args:
        df (dataframe): La dataframe pandas qui contient les tweets.
        start (str): La date de départ.

            Au format: `` &#34;%Y-%m-%d %H:%M:%S%z&#34;``.
        end (str): La date de fin

            Au format: `` &#34;%Y-%m-%d %H:%M:%S%z&#34;``.
        date_var (str): Le nom de la colonne qui contient la date

    Returns:
        pandas.dataframe: La dataframe filtrée par le temps.

    Examples:
        select_time_range(df, &#34;2020-11-03 08:15:00+01:00&#34;, &#34;2021-01-03 22:30:00+01:00&#34;)
    &#34;&#34;&#34;
    start_time = pd.to_datetime(start)
    end_time = pd.to_datetime(end)

    filtered_df = df[(start_time &lt; df[date_var]) &amp; (df[date_var] &lt; end_time)]

    return filtered_df</code></pre>
</details>
</dd>
<dt id="projet.processing.sentiment_class"><code class="name flex">
<span>def <span class="ident">sentiment_class</span></span>(<span>df, vars=['full_text', 'user-description'], choices=['tneg', 'neg', 'neutre', 'pos', 'tpos'])</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction pour ajouter une colonne pour les valeurs discrétisées de sentiment_analysis.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.dataframe</code></dt>
<dd>Une dataframe pandas du type <code><a title="projet.processing.create_full_text" href="#projet.processing.create_full_text">create_full_text()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sentiment_class(
    df,
    vars=[&#34;full_text&#34;, &#34;user-description&#34;],
    choices=[&#34;tneg&#34;, &#34;neg&#34;, &#34;neutre&#34;, &#34;pos&#34;, &#34;tpos&#34;],
):
    &#34;&#34;&#34;
    Fonction pour ajouter une colonne pour les valeurs discrétisées de sentiment_analysis.

    Args:
        df (pandas.dataframe): Une dataframe pandas du type `create_full_text`.
    &#34;&#34;&#34;
    conditions = lambda s: [
        (df[s + &#34;-sentiment-compound&#34;].lt(-0.7)),
        (
            df[s + &#34;-sentiment-compound&#34;].ge(-0.7)
            &amp; df[s + &#34;-sentiment-compound&#34;].lt(-0.2)
        ),
        (
            df[s + &#34;-sentiment-compound&#34;].ge(-0.2)
            &amp; df[s + &#34;-sentiment-compound&#34;].lt(0.2)
        ),
        (df[s + &#34;-sentiment-compound&#34;].ge(0.2) &amp; df[s + &#34;-sentiment-compound&#34;].lt(0.7)),
        (df[s + &#34;-sentiment-compound&#34;].ge(0.7)),
    ]

    for var in vars:
        df[var + &#34;-sentiment-class&#34;] = np.select(conditions(var), choices)

    return df</code></pre>
</details>
</dd>
<dt id="projet.processing.tweet_json_to_df"><code class="name flex">
<span>def <span class="ident">tweet_json_to_df</span></span>(<span>path_list=None, folder=None, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Convertit les fichiers json en dataframe pandas.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path_list</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Une liste des chemin vers les fichiers <code>.json</code>.</dd>
<dt><strong><code>folder</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>
<p>Le chemin du dossier qui contient les fichiers <code>.json</code>.</p>
<p>À terminer avec un <code>/</code> ou <code>\</code>.</p>
</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>
<p><code>True</code> pour afficher une barre de progrès et des messages.</p>
<p>Par défaut : <code>False</code>.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.dataframe</code></dt>
<dd>Dataframe pandas qui contient les tweets.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tweet_json_to_df(path_list=None, folder=None, verbose=False):
    r&#34;&#34;&#34;
    Convertit les fichiers json en dataframe pandas.

    Args:
        path_list (list, optional): 
            Une liste des chemin vers les fichiers `.json`.
        folder (str, optional): 
            Le chemin du dossier qui contient les fichiers `.json`.

            À terminer avec un `/` ou `\`.
        verbose (bool, optional): 
            `True` pour afficher une barre de progrès et des messages.

            Par défaut : `False`.

    Returns:
        pandas.dataframe: Dataframe pandas qui contient les tweets.
    &#34;&#34;&#34;
    assert path_list is not None or folder is not None, &#34;Un argument est nécessaire&#34;
    assert path_list is None or (
        path_list
        and isinstance(path_list, list)
        and all(isinstance(path, str) for path in path_list)
    ), &#34;&#39;path_list&#39; doit être une liste de strings&#34;
    assert folder is None or isinstance(
        folder, str
    ), &#34;&#39;folder&#39; doit être une chaîne de caractères&#34;

    if path_list is None:
        path_list = folder_to_path_list(folder_path=folder)

    if verbose:
        print(
            &#34;La conversion des fichiers &#39;json&#39; a commencé, cela peut prendre du temps&#34;
        )

    # Contient la liste des tweets en json
    tweets_list = []
    file_total = len(path_list)
    for i, path in enumerate(path_list):
        with open(path, &#34;r&#34;) as fh:
            tweets_json = fh.read().split(&#34;\n&#34;)
            for j, tweet in enumerate(tweets_json):
                tweet_total = len(tweets_json)
                if tweet:
                    tweet_obj = json.loads(tweet)
                    tweets_list.append(tweet_obj)
                utils.progressBar(
                    j, tweet_total, file=i + 1, total_file=file_total, verbose=verbose
                )
        if verbose:
            print(&#34;&#34;)

    # Créer une DataFrame à partir de `tweets_list`
    df_tweets = pd.DataFrame(tweets_list)

    return df_tweets</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="projet" href="index.html">projet</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="projet.processing.add_category" href="#projet.processing.add_category">add_category</a></code></li>
<li><code><a title="projet.processing.add_politics" href="#projet.processing.add_politics">add_politics</a></code></li>
<li><code><a title="projet.processing.add_sentiment" href="#projet.processing.add_sentiment">add_sentiment</a></code></li>
<li><code><a title="projet.processing.clean_df" href="#projet.processing.clean_df">clean_df</a></code></li>
<li><code><a title="projet.processing.create_full_text" href="#projet.processing.create_full_text">create_full_text</a></code></li>
<li><code><a title="projet.processing.folder_to_path_list" href="#projet.processing.folder_to_path_list">folder_to_path_list</a></code></li>
<li><code><a title="projet.processing.select_time_range" href="#projet.processing.select_time_range">select_time_range</a></code></li>
<li><code><a title="projet.processing.sentiment_class" href="#projet.processing.sentiment_class">sentiment_class</a></code></li>
<li><code><a title="projet.processing.tweet_json_to_df" href="#projet.processing.tweet_json_to_df">tweet_json_to_df</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>